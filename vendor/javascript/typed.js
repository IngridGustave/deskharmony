function w(r,n){return n instanceof r}function y(r){return"string"==typeof r}function b(r){return"number"==typeof r&&Number.isFinite(r)}function A(r){return"boolean"==typeof r}function R(r){return"bigint"==typeof r}function M(r){return"symbol"==typeof r}function S(r){return"undefined"==typeof r}function m(r){return"function"==typeof r}function N(r){return null===r}function g(r){return N(r)||S(r)}const r=[y,b,A,N,S,R,M];function D(n){return r.some((r=>r(n)))}function F(r){return w(Date,r)&&b(r.getTime())}function x(r){return Array.isArray(r)}function j(r){if(D(r))return!1;const n=Object.getPrototypeOf(r);return null===n||n===Object.prototype}function pr(r){if(g(r))return!1;const n=Object(r);return Symbol.iterator in n&&m(n[Symbol.iterator])}function lr(r){return"object"==typeof r&&null!==r&&"then"in r&&m(r.then)}function T(r){return!g(r)}function mr(r){return w(RegExp,r)}function dr(r){return w(Set,r)}function Er(r){return w(Map,r)}function q(r){return r>0}function Or(r){return!q(r)}function L(r){return Number.isInteger(r)}function hr(r){return!L(r)}function z(r){return r%2===0}function yr(r){return!z(r)}function wr(r){if(r<2)return!1;const n=Math.sqrt(r);for(let t=2;t<=n;t++)if(r%t===0)return!1;return!0}function d(r){throw y(r)?new Error(r):r}function br(r,n="Assertion failed"){r||d(n)}function gr(r){return r}function i(r){return{and:()=>i(r),andThen:()=>i(r),err:()=>l(r),expect:r=>d(r),expectErr:()=>r,inspect:()=>i(r),inspectErr:n=>(n(r),i(r)),isErr:()=>!0,isErrAnd:n=>n(r),isOk:()=>!1,isOkAnd:()=>!1,map:()=>i(r),mapErr:n=>i(n(r)),mapOr:r=>r,mapOrElse:n=>n(r),match:(n,t)=>t(r),ok:()=>n,or:r=>r,orElse:n=>n(r),unwrap:()=>d("called Result.unwrap on an `Err` value"),unwrapErr:()=>r,unwrapOr:r=>r,unwrapOrElse:n=>n(r)}}function s(r){return{and:r=>r,andThen:n=>n(r),err:()=>n,expect:()=>r,expectErr:r=>d(r),inspect:n=>(n(r),s(r)),inspectErr:()=>s(r),isErr:()=>!1,isErrAnd:()=>!1,isOk:()=>!0,isOkAnd:n=>n(r),map:n=>s(n(r)),mapErr:()=>s(r),mapOr:(n,t)=>t(r),mapOrElse:(n,t)=>t(r),match:n=>n(r),ok:()=>l(r),or:()=>s(r),orElse:()=>s(r),unwrap:()=>r,unwrapErr:()=>d("called Result.unwrapErr on an `Ok` value"),unwrapOr:()=>r,unwrapOrElse:()=>r}}function jr(r){try{return s(r())}catch(r){return i(r)}}function C(r){return m(r)?C(r()):r.then(s).catch(i)}function kr(r){return j(r)&&"isOk"in r&&m(r.isOk)&&"isErr"in r&&m(r.isErr)}const n=J();function J(){return{and:()=>n,andThen:()=>n,expect:r=>d(r),filter:()=>n,inspect:()=>n,isNone:()=>!0,isSome:()=>!1,isSomeAnd:()=>!1,map:()=>n,mapOr:r=>r,mapOrElse:r=>r(),match:(r,n)=>n(),or:r=>r,orElse:r=>r(),unwrap:()=>d("called Option.unwrap on a `None` value"),unwrapOr:r=>r,unwrapOrElse:r=>r(),okOr:r=>i(r),okOrElse:r=>i(r())}}function l(r){return{and:r=>r,andThen:n=>n(r),expect:()=>r,filter:t=>t(r)?l(r):n,inspect:n=>(n(r),l(r)),isNone:()=>!1,isSome:()=>!0,isSomeAnd:n=>n(r),map:n=>l(n(r)),mapOr:(n,t)=>t(r),mapOrElse:(n,t)=>t(r),match:n=>n(r),or:()=>l(r),orElse:()=>l(r),unwrap:()=>r,unwrapOr:()=>r,unwrapOrElse:()=>r,okOr:()=>s(r),okOrElse:()=>s(r)}}function _(r){return T(r)?l(r):n}function Sr(r){return j(r)&&"isSome"in r&&m(r.isSome)&&"isNone"in r&&m(r.isNone)}function E(r,n){return n<0?r.length+n:n}function k(r,n){return _(r[E(r,n)])}function U(r,n,t){t=E(r,t);const e=[...r];return e.splice(t,0,n),e}function V(r,n,t){n=E(r,n),t=E(r,t);const e=[...r],o=e.splice(n,1)[0];return e.splice(t,0,o),e}function G(r,n){n=E(r,n);const t=[...r];return t.splice(n,1),t}function H(r){const n=[...r];for(let r=n.length-1;r>0;r--){const t=Math.floor(Math.random()*(r+1)),e=n[r];n[r]=n[t],n[t]=e}return n}function K(r,n,t){n=E(r,n),t=E(r,t);const e=[...r],o=e[n];return e[n]=e[t],e[t]=o,e}function Ar(r,n,t=1){const e=[];let o=r;for(;o<=n;)e.push(o),o+=t;return e}function I(r,n){const t=Object.create(null);for(let e=0;e<r.length;e++){const o=r[e],u=n(o,e);u in t||(t[u]=[]),t[u].push(o)}return t}function Q(r,n){return I(r,(r=>r[n]))}function c(r){const n=S(r)?[]:Array.isArray(r)?r:Array.from(r);return{*[Symbol.iterator](){yield*n[Symbol.iterator]()},append:(...r)=>c([...n,...r]),at:r=>k(n,r),concat:r=>c([...n,...r]),compact:()=>c(n.filter(T)),drop:r=>c(n.slice(r)),each:r=>(n.forEach(r),c(n)),every:r=>n.every(r),filter:r=>c(n.filter(r)),find:r=>_(n.find(r)),first:()=>k(n,0),group:r=>I(n,r),groupBy:r=>Q(n,r),includes:r=>n.includes(r),insert:(r,t)=>c(U(n,r,t)),isEmpty:()=>0===n.length,last:()=>k(n,-1),len:()=>n.length,map:r=>c(n.map(r)),move:(r,t)=>c(V(n,r,t)),prepend:(...r)=>c([...r,...n]),reduce:(r,t)=>n.reduce(t,r),remove:r=>c(G(n,r)),reverse:()=>c([...n].reverse()),shuffle:()=>c(H(n)),some:r=>n.some(r),sort:r=>c([...n].sort(r)),swap:(r,t)=>c(K(n,r,t)),take:r=>c(n.slice(0,r)),toArray:()=>[...n],toJSON:()=>[...n]}}function f(){return{path:[],message:"",actual:"",expected:""}}const P=r=>n=>{if(!x(n))return i(f());const t=new Array(n.length);for(let e=0;e<n.length;e++){const o=r(n[e]);if(o.isErr())return i(o.unwrapErr());t.push(o.unwrap())}return s(t)},W=r=>n=>{if(null!=r&&r.coerce)if(y(n))switch(n.toLowerCase()){case"true":case"yes":case"on":n=!0;break;default:n=!1}else n=Boolean(n);return A(n)?s(n):i(f())};function X(r,...n){return t=>r(t).andThen((r=>s(n.reduce(((r,n)=>n(r)),r))))}const Y=r=>n=>(null!=r&&r.coerce&&(b(n)||y(n))&&(n=new Date(n)),F(n)?s(n):i(f())),Z=(r,n)=>t=>g(t)?s(n):r(t),$=r=>{const n=Object.values(r);return r=>n.includes(r)?s(r):i(f())},v=r=>n=>{const t=Object.create(null);for(const e of r){const r=e(n);if(r.isErr())return i(r.unwrapErr());Object.assign(t,r.unwrap())}return s(t)},rr=r=>{const n=P(r);return r=>n(r).andThen((r=>s(c(r))))},nr=r=>n=>n===r?s(n):i(f());function tr(r,n){return t=>r(t).andThen(n)}const er=r=>n=>(null!=r&&r.coerce&&(n=Number(n)),b(n)?s(n):i(f()));function or(r){const n=Object.entries(r);return r=>{if(!j(r))return i(f());const t=Object.create(null);for(const[r,e]of n){const n=e(t[r]);if(n.isErr())return i(n.unwrapErr())}return s(t)}}const sr=r=>t=>g(t)?s(n):r(t).andThen((r=>s(l(r)))),ir=(r,n)=>t=>{if(!j(t))return i(f());const e=Object.create(null);for(const[o,u]of Object.entries(t)){const t=r(o);if(t.isErr()){const r=t.unwrapErr();return r.path.unshift(o),i(r)}const a=n(u);if(a.isErr()){const r=a.unwrapErr();return r.path.unshift(o),i(r)}e[t.unwrap()]=a.unwrap()}return s(e)},cr=r=>n=>(null!=r&&r.coerce&&(n=String(n)),y(n)?s(null!=r&&r.trim?n.trim():n):i(f())),ur=r=>{const n=[...r.entries()];return t=>{if(!x(t))return i(f());const e=new Array(r.length);for(const[r,o]of n){const n=o(t[r]);if(n.isErr()){const t=n.unwrapErr();return t.path.unshift(r.toString()),i(t)}e[r]=n.unwrap()}return s(e)}},fr=r=>n=>{for(const t of r){const r=t(n);if(r.isOk())return s(r.unwrap())}return i(f())},ar=r=>s(r),t=Object.freeze(Object.defineProperty({__proto__:null,array:P,boolean:W,chain:X,date:Y,defaulted:Z,enums:$,intersection:v,list:rr,literal:nr,map:tr,number:er,object:or,optional:sr,record:ir,string:cr,tuple:ur,union:fr,unknown:ar},Symbol.toStringTag,{value:"Module"}));export{i as Err,c as List,n as None,s as Ok,l as Some,br as assert,gr as identity,x as isArray,R as isBigInt,A as isBoolean,F as isDate,z as isEven,hr as isFloat,m as isFunction,w as isInstanceOf,L as isInteger,pr as isIterable,Er as isMap,Or as isNegative,g as isNil,N as isNull,b as isNumber,yr as isOdd,Sr as isOption,j as isPlainObject,q as isPositive,T as isPresent,wr as isPrime,D as isPrimitive,lr as isPromise,mr as isRegExp,kr as isResult,dr as isSet,y as isString,M as isSymbol,S as isUndefined,d as raise,Ar as range,t,C as toAsyncResult,_ as toOption,jr as toResult};

